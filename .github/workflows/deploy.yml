name: build-and-deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Lowercase the owner for GHCR image paths (required)
      - name: Compute lowercase owner
        run: echo "OWNER_LC=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_ENV"

      # Backend image
      - name: Build & push backend
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ghcr.io/${{ env.OWNER_LC }}/job-apply-bot-final-backend:latest
            ghcr.io/${{ env.OWNER_LC }}/job-apply-bot-final-backend:${{ github.sha }}

      # Frontend image
      - name: Build & push frontend
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ghcr.io/${{ env.OWNER_LC }}/job-apply-bot-final-frontend:latest
            ghcr.io/${{ env.OWNER_LC }}/job-apply-bot-final-frontend:${{ github.sha }}

      # Playwright image (optional)
      - name: Build & push playwright
        uses: docker/build-push-action@v5
        with:
          context: ./playwright-service
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ghcr.io/${{ env.OWNER_LC }}/job-apply-bot-final-playwright:latest
            ghcr.io/${{ env.OWNER_LC }}/job-apply-bot-final-playwright:${{ github.sha }}
            
  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Verify workspace contents
      run: |
        set -euxo pipefail
        pwd
        ls -la
        find . -maxdepth 2 -name 'docker-compose*' -print
        test -f docker-compose.yml
        test -f docker-compose.prod.yml

    - name: Upload repo via SCP (send entire repo)
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.SSH_HOST }}
        username: ${{ secrets.SSH_USER }}
        key: ${{ secrets.SSH_KEY }}
        port: ${{ secrets.SSH_PORT || 22 }}
        source: |
          .
        target: /home/ubuntu/job-apply-bot-final
        rm: true
        overwrite: true
        strip_components: 0
        debug: true

    - name: SSH deploy
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.SSH_HOST }}
        username: ${{ secrets.SSH_USER }}
        key: ${{ secrets.SSH_KEY }}
        port: ${{ secrets.SSH_PORT || 22 }}
        script_stop: true
        script: |
          set -euo pipefail

          DOMAIN='${{ secrets.DOMAIN }}'
          EMAIL='${{ secrets.EMAIL }}'
          DEPLOY_PATH='/home/ubuntu/job-apply-bot-final'

          echo "➡ Using DEPLOY_PATH: [$DEPLOY_PATH]"
          sudo mkdir -p "$DEPLOY_PATH"
          sudo chown "$USER":"$USER" "$DEPLOY_PATH"

          echo "➡ Listing DEPLOY_PATH:"
          ls -la "$DEPLOY_PATH" || true
          echo "➡ Compose files found:"
          find "$DEPLOY_PATH" -maxdepth 2 -type f -name 'docker-compose*.yml' -print || true

          # Install Docker if missing
          if ! command -v docker >/dev/null 2>&1; then
            curl -fsSL https://get.docker.com | sudo sh
          fi

          # Optional GHCR login if your packages are private
          if [ -n '${{ secrets.GHCR_USERNAME }}' ] && [ -n '${{ secrets.GHCR_TOKEN }}' ]; then
            echo '${{ secrets.GHCR_TOKEN }}' | sudo docker login ghcr.io -u '${{ secrets.GHCR_USERNAME }}' --password-stdin
          fi

          COMPOSE="-f $DEPLOY_PATH/docker-compose.yml -f $DEPLOY_PATH/docker-compose.prod.yml"

          sudo docker compose $COMPOSE pull
          sudo docker compose $COMPOSE up -d

          # First-run cert issuance: override any entrypoint and run the certbot CLI directly
          if ! sudo docker compose $COMPOSE exec -T frontend test -f "/etc/letsencrypt/live/${DOMAIN}/fullchain.pem"; then
            sudo docker compose $COMPOSE run --rm --entrypoint "" certbot \
              certbot certonly --webroot -w /var/www/certbot \
              -d "${DOMAIN}" --email "${EMAIL}" --agree-tos --no-eff-email

            sudo docker compose $COMPOSE exec -T frontend nginx -s reload || true
          fi

          # Health checks
          curl -I --max-time 10 "http://${DOMAIN}"  || true
          curl -I --max-time 10 "https://${DOMAIN}" || true
          curl -I --max-time 10 "https://${DOMAIN}/api/jobs" || true
